# 思路
将两个链表的数据转换成int型数据，然后int相加得到目标数，然后再将目标数拆分成数字放在列表里。
# 缺陷
即使换成long long太大的数字也存不下
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    long long num1=0,num2=0,num3=0;
    int num[200]={0};
    int i = 0,j=0,k=0;
    struct ListNode *tmp;
    tmp = l1;
    while(tmp != NULL)
    {
        num1=num1+tmp->val*pow(10,i);
        i++;
        tmp = tmp->next;
    }
    tmp = l2;
    while(tmp != NULL)
    {
        num2=num2+tmp->val*pow(10,j);
        j++;
        tmp = tmp->next;
    }
    num3 = num1+num2;
    do // 0+0至少要循环一次，不然k值不累加，导致后面申请0空间
    {
        num[k]=num3%10;
        num3=num3/10;
        k++;
    }while(num3!=0);
    // printf("%d\n",k);
    struct ListNode *p=(struct ListNode*)malloc(sizeof(struct ListNode)*k); // malloc空间要强制转换类型
    for(i=0;i<k-1;i++)
    {
        p[i].val=num[i]; // p[i]是实例,用.
        p[i].next=p+i+1; // p[i].next=&(p[i+1]);要加取地址符
    }
    p[k-1].val=num[k-1];
    p[k-1].next=NULL; // 一定要指向null,申请空间后里面内容随机
    // struct ListNode* s=p;
    // while(s!=NULL)
    // {

    //     printf("%d\n",s->val);
    //     s=s->next;
    // }
    return p;

}
```
