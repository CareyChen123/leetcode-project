# 思路一 我们可以重复「弹出」x 的末尾数字，将其「推入」rev 的开头（result = resuult*10 + num)数字，直至 x 为 0。int 存储数字范围[-2^31,2^31-1],当数字反转超过int存储最大数字时会越界，所以用long定义result
```c
int reverse(int x){
    long result = 0; // 如果是int则反转后存储可能会越界
    int number = 0;
    while(x!=0) // 循环的次数就是x的位数x，10^m=x,x=log(|x|)所以时间复杂度为log(|x|)
    {
        number = x%10;
        // printf("%d\n",number); // 负数除和取余结果也是负数
        x=x/10;
        // printf("%d\n",x);
        result = result*10 + number; // 原来的数乘10会向高位移动一位
    }
    if(result > (pow(2,31)-1) || result < (-1 *pow(2,31)))
        return 0;
    return result;
}
```
