# 思路
    通过三层循环来完成，第一次循环确定子串头从哪里开始；第二层循环确定子串尾从哪里开始，并在第三层循环判定满足不重复的需求后，计算子串长度并赋给len_max，或者跳出j循环；第三层循环判断第二层指针指的位置是否可以满足不重复的需求,
不满足的就置flag=1,尾部就不再往后移动了。
```c
int lengthOfLongestSubstring(char * s){
    int i=0,j=0,m=0;
    int flag=0;
    int len_max=0;
    // int len_max=1; // 当末尾字符作为头的时候,len_max=1,所以初始化为1

    //  if(strlen(s)==0) // 测试用例位""
    //      return 0;

    for(i;i<strlen(s);i++)
    {
        for(j=i;j<strlen(s);j++) // j从i开始，对应该位置既是字串头，又是字串尾的情况，也可以从j+1开始，但是len_max初始化为1，空字串另行处理
        {
            for(m=i;m<j;m++)
            {
                if(s[m]==s[j])
                {
                    flag=1;
                }
            }
            if(flag==0)
            {
                if(len_max<(j-i+1))
                {
                    printf("i=%d,j=%d\n",i,j);
                    len_max=j-i+1;
                }
            }else
            {
                flag=0; // 此时i作为头，j到j<len(s)作为尾的字串就不符合条件了，要结束j循环
                break;
            }
        }
    }
    return len_max;

}
```
