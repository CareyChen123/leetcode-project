# 思路一：遍历每一个子串，判断是否是合法的，是的话就统计长度，最后保留最长的。（超时无法通过所有测试用例）
```c
class Solution {
public:
    int longestValidParentheses(string s) {
        int res=0;
        int len=0;
        for(int i=0; i<s.size(); i++)
        {
            if(s[i]==')')
                continue;
            for(int j=i+1; j<s.size(); j=j+2)
            {
                len=j-i+1;
                // cout<<i<<" "<<j<<" "<<s.substr(i,len)<<endl;
                if(isValid(s.substr(i,len)))
                {
                    // i=i+len-1;
                    if(len>res)
                        res=len;
                    // cout<<res<<endl;
                }
            }
        }
        return res;
    }
    bool isValid(string s)
    {
        vector<char> statck;
        int top=0;
        for(int i=0; i<s.size(); i++)
        {
            // cout<<"size:"<<statck.size()<<top<<" "<<s[i]<<endl;
            if(s[i]=='(')
            {
                // cout<<"carey:"<<s[i]<<endl;
                statck.push_back(s[i]);
                top++;
            }else{
                if(top==0 || (s[i]==')'&&statck[top-1]!='('))
                {
                    // cout<<"wangle"<<statck[top-1]<<endl;
                    return false;
                }else{
                    // cout<<"carey"<<endl;
                    statck.pop_back();
                    top--;
                }
            }  
        }
        // cout<<"top:"<<top<<s<<endl;
        return top==0;
    }
};
```
