# 思路一：创建一个Listnode *的向量存储指向链表每一个节点的指针;然后调整每一段k反转后指针指向的位置，由于每一个节点我们都能通过新定义的向量找到，所以后续操作会很方便。注意临界那段k个节点链表的处理。
```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        int num=0;
        int j=0;
        vector<ListNode *> node; 
        ListNode *tmp=head;
        while(tmp!=NULL)
        {
            node.push_back(tmp);
            num++;
            tmp=tmp->next;
        }
        if(num>=k)
            head=node[k-1];
        cout<<num<<endl;
        while(num>=k)
        {
            cout<<"aaa:"<<num<<" "<<j<<endl;
            for(int i=0; i<k; i++)
            {
                cout<<i<<" "<<j<<" "<<k<<endl;
                if(i==0)
                {
                    if((k*(j+2)-1)<=(node.size()-1)) //如果下一段k还完整
                        node[k*j]->next=node[k*(j+2)-1];
                    else if((k*(j+1))<=(node.size()-1)) //如果正好是最后一段k个，后面还有其他节点，但没有k个了
                        node[k*j]->next=node[k*(j+1)];
                    else //最后一段k,且后面没有其他节点了
                        node[k*j]->next=NULL;
                    continue;
                }
                node[k*j+i]->next=node[k*j+i-1];
            }
            j++;
            num=num-k;
        }
        return head;
    }
};
```
